<!DOCTYPE html>
<html>
<head>
    <title>Voice API Test - Standalone</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        button { padding: 10px 20px; margin: 10px; font-size: 16px; }
        #results { background: #f5f5f5; padding: 15px; margin: 10px 0; min-height: 100px; white-space: pre-wrap; }
        .error { color: red; }
        .success { color: green; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>Voice API Test - Direct Testing</h1>
    
    <h2>Test Options:</h2>
    <button onclick="testAPIConnection()">1. Test API Health</button>
    <button onclick="testWithMinimalFile()">2. Test with Minimal WAV</button>
    <button onclick="testRecordAndSend()">3. Record Real Audio & Send</button>
    
    <h2>Results:</h2>
    <div id="results">Click a button above to test...</div>

    <script>
        const results = document.getElementById('results');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            results.innerHTML += `[${timestamp}] ${message}\n`;
            results.className = type;
            console.log(message);
        }
        
        function clearResults() {
            results.innerHTML = '';
        }
        
        // Test 1: Basic API health check
        async function testAPIConnection() {
            clearResults();
            log('üîç Testing API connection...', 'info');
            
            try {
                // First test the root endpoint
                log('Testing root endpoint...');
                const rootResponse = await fetch('https://socialdots-ai-expense-backend.hf.space/');
                const rootText = await rootResponse.text();
                log(`Root endpoint: ${rootResponse.status} - ${rootText}`, 'success');
                
                // Test voice-suggestion endpoint with OPTIONS
                log('Testing voice-suggestion with OPTIONS...');
                const optionsResponse = await fetch('https://socialdots-ai-expense-backend.hf.space/voice-suggestion', {
                    method: 'OPTIONS'
                });
                log(`OPTIONS response: ${optionsResponse.status}`, 'success');
                log(`Allowed methods: ${optionsResponse.headers.get('allow') || 'Not specified'}`);
                
            } catch (error) {
                log(`‚ùå Connection test failed: ${error.message}`, 'error');
            }
        }
        
        // Test 2: Send minimal WAV file
        async function testWithMinimalFile() {
            clearResults();
            log('üéµ Testing with minimal WAV file...', 'info');
            
            try {
                // Create a proper minimal WAV file with some actual audio data
                const sampleRate = 44100;
                const duration = 1; // 1 second
                const samples = sampleRate * duration;
                
                // Create WAV header
                const buffer = new ArrayBuffer(44 + samples * 2);
                const view = new DataView(buffer);
                
                // RIFF header
                view.setUint32(0, 0x46464952, true); // "RIFF"
                view.setUint32(4, buffer.byteLength - 8, true);
                view.setUint32(8, 0x45564157, true); // "WAVE"
                
                // fmt chunk
                view.setUint32(12, 0x20746d66, true); // "fmt "
                view.setUint32(16, 16, true); // chunk size
                view.setUint16(20, 1, true); // audio format (PCM)
                view.setUint16(22, 1, true); // num channels
                view.setUint32(24, sampleRate, true); // sample rate
                view.setUint32(28, sampleRate * 2, true); // byte rate
                view.setUint16(32, 2, true); // block align
                view.setUint16(34, 16, true); // bits per sample
                
                // data chunk
                view.setUint32(36, 0x61746164, true); // "data"
                view.setUint32(40, samples * 2, true); // data size
                
                // Generate simple sine wave
                for (let i = 0; i < samples; i++) {
                    const sample = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.3; // 440Hz tone
                    view.setInt16(44 + i * 2, sample * 32767, true);
                }
                
                const wavBlob = new Blob([buffer], { type: 'audio/wav' });
                log(`Created WAV file: ${wavBlob.size} bytes`, 'success');
                
                const formData = new FormData();
                formData.append('file', wavBlob, 'test_tone.wav');
                
                log('Sending to voice-suggestion endpoint...');
                const response = await fetch('https://socialdots-ai-expense-backend.hf.space/voice-suggestion', {
                    method: 'POST',
                    body: formData
                });
                
                log(`Response status: ${response.status}`, response.ok ? 'success' : 'error');
                log(`Response headers: ${JSON.stringify(Object.fromEntries(response.headers.entries()), null, 2)}`);
                
                const responseText = await response.text();
                log(`Response body: ${responseText}`, response.ok ? 'success' : 'error');
                
                if (response.ok) {
                    try {
                        const jsonData = JSON.parse(responseText);
                        log('‚úÖ SUCCESS! Got valid JSON response:', 'success');
                        log(JSON.stringify(jsonData, null, 2));
                    } catch (e) {
                        log('‚ö†Ô∏è Response is not JSON format', 'error');
                    }
                }
                
            } catch (error) {
                log(`‚ùå Test failed: ${error.message}`, 'error');
                log(`Error stack: ${error.stack}`);
            }
        }
        
        // Test 3: Record real audio and send
        async function testRecordAndSend() {
            clearResults();
            log('üé§ Starting real audio recording test...', 'info');
            
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('MediaDevices not supported in this browser');
                }
                
                log('Requesting microphone access...');
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        sampleRate: 16000,
                        channelCount: 1
                    } 
                });
                
                log('‚úÖ Microphone access granted', 'success');
                log('Recording for 3 seconds... Please speak now!');
                
                const mediaRecorder = new MediaRecorder(stream);
                const chunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    chunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    log('Recording stopped, processing...', 'info');
                    
                    const audioBlob = new Blob(chunks, { type: 'audio/webm' });
                    log(`Recorded blob: ${audioBlob.size} bytes, type: ${audioBlob.type}`, 'success');
                    
                    const formData = new FormData();
                    formData.append('file', audioBlob, 'recorded_audio.webm');
                    
                    log('Sending recorded audio to API...');
                    try {
                        const response = await fetch('https://socialdots-ai-expense-backend.hf.space/voice-suggestion', {
                            method: 'POST',
                            body: formData
                        });
                        
                        log(`Response status: ${response.status}`, response.ok ? 'success' : 'error');
                        const responseText = await response.text();
                        log(`Response: ${responseText}`, response.ok ? 'success' : 'error');
                        
                    } catch (fetchError) {
                        log(`‚ùå Fetch error: ${fetchError.message}`, 'error');
                    }
                    
                    // Stop all tracks
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                
                // Stop after 3 seconds
                setTimeout(() => {
                    mediaRecorder.stop();
                }, 3000);
                
            } catch (error) {
                log(`‚ùå Recording test failed: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>